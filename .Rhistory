optimised.probs<-data.frame(sapply(fit$xlevels[[variable]],
FUN=function(q){
P.X(X=optimised$minimum,
outcome = 1:length(fit$lev),
variable = variable,
value = q)}))
optimised.probs<-cbind(1:length(fit$lev),optimised.probs)
names(optimised.probs)[1]<-names(fit$model[1])
optimised.probs
}
recommend("ethnicity")
require(MASS)
# require(foreign)
# dat <- read.dta("http://www.ats.ucla.edu/stat/data/ologit.dta")
test.data <- read.csv("~/GitHub/perfman/test data.csv")
test.data$age <- factor(test.data$age, levels = c(1,2,3,4))
test.data$outcome <- factor(test.data$outcome, levels = c(1,2,3,4))
#ask for what to do with missing values
#default is to replace all missing values NA with "NA"
#fit the ordered logistic model
fit<-polr(data = test.data)
#create the cuts as a numeric vector
cuts<-numeric(length(fit$zeta)+2)
cuts[2:(length(fit$zeta)+1)]<-fit$zeta
cuts[c(1,length(cuts))]<-c(-Inf,Inf)
#create a vector of names of explanatory variables
variables<-attr(fit$terms,"term.labels")
#create the coefficient lookup function
#a convenient function for reading off the estimated coefficients for all
#the explanatory variables (including zero for baseline values)
coef.lookup<-function(variable,value){
if (!(variable %in% variables)) {
stop("variable not in model")
} else if (!(value %in% fit$xlevels[[variable]])) {
stop("value not observed for this variable")
} else if (fit$xlevels[[variable]][[1]]==value) {
return (0)
} else
return (fit$coefficients[[paste0(variable,value)]])
}
#create function P.X(X, outcome, variable, value) that will be treated
#as a function of X and give a specific probability for given outcome k for
#specific value of a specific variable
#what happens with invalid variables/values??
P.X<-function(X,outcome,variable,value){
(1+exp(X+coef.lookup(variable,value)-cuts[outcome+1]))^-1-(1+exp(X+coef.lookup(variable,value)-cuts[outcome]))^-1
}
#get observed proportions of each variable in the data (including outcome)
counts.raw<-apply(test.data,2,table)
proportions.raw<-lapply(counts.raw,FUN = function(x){x/nrow(test.data)})
#create fucntion proportions.implied(X, outcome=k, variable=v)
#that will give the implied proportion for outcome k in BIS assuming X and v
#GIVEN VARIABLE e,g, GENDER, what is the implied proportion for outcome k?
implied.proportion<-function(X,outcome,variable){
implieds<-rep(0,length(fit$xlevels[[variable]]))
for (i in fit$xlevels[[variable]]){
implieds[i]<-P.X(X=X,outcome = outcome,variable = variable,value = i)*
proportions.raw[[variable]][[i]]
}
return(sum(implieds))
}
#GIVEN VARIABLE, find the sqaured error as a function of X
squared.error<-function(X,variable){
outcome.errors<-rep(0,length(fit$lev))
for (i in 1:length(fit$lev)){
outcome.errors[i]<-
(implied.proportion(X=X,outcome = i,variable = variable)-
proportions.raw[[1]][[i]])^2
}
return(sum(outcome.errors))
}
#find answer for given variable
recommend<-function(variable){
if (!(variable %in% variables)) {
stop("variable not in model")
}
optimised<-optimise(f = function(x){squared.error(x,variable)},
interval = c(-100,100))
message("The recommended value of X is ",optimised$minimum)
#create data frame with outcomes along the top and variable values down the side
#    optimised.probs<-matrix(nrow = length(fit$lev),
#                           ncol = length(fit$xlevels[[variable]]))
optimised.probs<-data.frame(sapply(fit$xlevels[[variable]],
FUN=function(q){
P.X(X=optimised$minimum,
outcome = 1:length(fit$lev),
variable = variable,
value = q)}))
optimised.probs<-cbind(1:length(fit$lev),optimised.probs)
names(optimised.probs)[1]<-names(fit$model[1])
optimised.probs
}
recommend("outcome")
recommend("age")
recommend("ethnicity")
recommend("gender")
recommend("disability")
implied.proportion(X = -1.257909,outcome = 1,variable = "disability")
implied.proportion(X = -1.257909,outcome = 1:4,variable = "disability")
sapply(1:4, FUN=function(q){implied.proportion(X=-1.25790946248166,outcome = q,variable = "disability")})
recommend<-function(variable){
if (!(variable %in% variables)) {
stop("variable not in model")
}
optimised<-optimise(f = function(x){squared.error(x,variable)},
interval = c(-100,100))
message("The recommended value of X is ",optimised$minimum)
#create data frame with outcomes along the top and variable values down the side
#    optimised.probs<-matrix(nrow = length(fit$lev),
#                           ncol = length(fit$xlevels[[variable]]))
optimised.probs<-data.frame(sapply(fit$xlevels[[variable]],
FUN=function(q){
P.X(X=optimised$minimum,
outcome = 1:length(fit$lev),
variable = variable,
value = q)}))
optimised.probs<-cbind(1:length(fit$lev),
sapply(1:length(fit$lev), FUN=function(q){
implied.proportion(X=optimised$minimum,
outcome = q,
variable = variable)}),
optimised.probs)
names(optimised.probs)[1]<-names(fit$model[1])
names(optimised.probs)[2]<-"implied probability"
optimised.probs
}
recommend("disability")
require(MASS)
recommend("disability")
fit
summary(fit)
cuts
variables
counts.raw
proportions.raw
implied.proportion
recommend("age")
recommend("ethnicity")
recommend("age")
recommend("gender")
recommend("disability")
squared.error(-1.258,"disability")
squared.error(-1.358,"disability")
squared.error(-1.158,"disability")
recommed(age)
recommend(age)
recommend("ag")
str(age)
str("age")
optimised.probs
recommend("ethnicity")
test.data.original<-test.data
plot(test.data$outcomes)
plot(test.data$outcomes,xlim=1)
hist(test.data$outcomes)
str(test.data$outcomes)
str(test.data)
plot(test.data$outcome)
plot(test.data$gender)
plot(test.data$outcome, test.data$gender)
plot(test.data$outcome, test.data$ethnicity)
plot(test.data$outcome, test.data$age)
plot(test.data$outcome, test.data$disability)
abc<-read.table(file = "~/GitHub/perfman/Book1.xlsx",header = TRUE,stringsAsFactors = TRUE)
abc<-NULL
abc <- read.delim("~/GitHub/perfman/Book1.txt")
View(abc)
str(abc$age)
str(abc)
str(abc$Age)
summary(abc$Age)
abc$Outcome
str(abc$Outcome)
abc$Outcome<-factor(abc$Outcome, levels=c(1,2,3,4))
summary(abc$Outcome)
str(abc$Outcome)
test.data<-abc
fit<-polr(data = test.data)
require(MASS) #or library(MASS) ?
fit<-polr(data = test.data)
abc <- read.delim("~/GitHub/perfman/Book1.txt")
View(abc)
abc$Outcome<-factor(abc$Outcome, levels=c(1,2,3,4))
fit<-polr(data = test.data)
test.data<-abc
fit<-polr(data = test.data)
abc <- read.delim("~/GitHub/perfman/Book1.txt")
View(abc)
abc$Outcome<-factor(abc$Outcome, levels=c(1,2,3,4))
test.data<-abc
fit<-polr(data = test.data)
cuts<-numeric(length(fit$zeta)+2)
cuts[2:(length(fit$zeta)+1)]<-fit$zeta
cuts[c(1,length(cuts))]<-c(-Inf,Inf)
variables<-attr(fit$terms,"term.labels")
variables
coef.lookup<-function(variable,value){
if (!(variable %in% variables)) {
stop("variable not in model")
} else if (!(value %in% fit$xlevels[[variable]])) {
stop("value not observed for this variable")
} else if (fit$xlevels[[variable]][[1]]==value) {
return (0)
} else
return (fit$coefficients[[paste0(variable,value)]])
}
#create function P.X(X, outcome, variable, value) that will be treated
#as a function of X and give a specific probability for given outcome k for
#specific value of a specific variable
#what happens with invalid variables/values??
P.X<-function(X,outcome,variable,value){
(1+exp(X+coef.lookup(variable,value)-cuts[outcome+1]))^-1-
(1+exp(X+coef.lookup(variable,value)-cuts[outcome]  ))^-1
}
#get observed proportions of each variable in the data (including outcome)
counts.raw<-apply(test.data,2,table)
proportions.raw<-lapply(counts.raw,FUN = function(x){x/nrow(test.data)})
#create function proportions.implied(X, outcome=k, variable=v)
#that will give the implied proportion for outcome k in the population assuming
#X and v
#GIVEN VARIABLE e,g, GENDER, what is the implied proportion for outcome k?
implied.proportion<-function(X,outcome,variable){
implieds<-rep(0,length(fit$xlevels[[variable]]))
for (i in fit$xlevels[[variable]]){
implieds[i]<-P.X(X=X,outcome = outcome,variable = variable,value = i)*
proportions.raw[[variable]][[i]]
}
return(sum(implieds))
}
#GIVEN VARIABLE, find the sqaured error as a function of X
squared.error<-function(X,variable){
outcome.errors<-rep(0,length(fit$lev))
for (i in 1:length(fit$lev)){
outcome.errors[i]<-
(implied.proportion(X=X,outcome = i,variable = variable)-
proportions.raw[[1]][[i]])^2
}
return(sum(outcome.errors))
}
#find answer for given variable
recommend<-function(variable){
if (!(variable %in% variables)) {
stop("variable not in model")
}
optimised<-optimise(f = function(x){squared.error(x,variable)},
interval = c(-100,100))
message("The recommended value of X is ",optimised$minimum)
#create data frame with outcomes along the top and variable values down the side
#optimised.probs<-matrix(nrow = length(fit$lev),
#                        ncol = length(fit$xlevels[[variable]]))
optimised.probs<-data.frame(sapply(fit$xlevels[[variable]],
FUN=function(q){
P.X(X=optimised$minimum,
outcome = 1:length(fit$lev),
variable = variable,
value = q)}))
optimised.probs<-cbind(1:length(fit$lev),
sapply(1:length(fit$lev), FUN=function(q){
implied.proportion(X=optimised$minimum,
outcome = q,
variable = variable)}),
optimised.probs)
names(optimised.probs)[1]<-names(fit$model[1])
names(optimised.probs)[2]<-"implied probability"
optimised.probs
}
counts.raw
proportions.raw
proportions.raw
variables
recommend("GROUP")
recommend("Grade")
recommend("Gender")
recommend("Ethnicity")
recommend("Sexual.Orientation")
recommend("Relig")
recommend("Age")
fit$coefficients
coef.lookup("Age","20s")
coef.lookup("Age","30s")
coef.lookup("Age","40s")
coef.lookup("Age","50s")
coef.lookup("Age","60s")
squared.error(0,"Age")
length(fit$lev)
fit$lev
proportions.raw[[1]][[1]]
proportions.raw[[1]][[2]]
proportions.raw[[1]][[3]]
proportions.raw[[1]][[4]]
implied.proportion(X = 0,outcome = 1,variable = "Age")
implied.proportion(X = 0,outcome = 1,variable = "Gender")
implied.proportion(X = 0,outcome = 1,variable = "Age")
fit$xlevels[[Age]]
fit$xlevels[["Age"]]
summary(test.data$Age)
test.data<-abc[abc$Age!="Not Declared",]
fit<-polr(data = test.data)
recommend"Age"
recommend("Age")
fit$lev
fit$coefficients
summary(test.data$Age)
abc <- read.delim("~/GitHub/perfman/Book1.txt", dec=",")
View(abc)
abc <- read.delim("~/GitHub/perfman/Book1.txt")
View(abc)
abc$Outcome<-factor(abc$Outcome, levels=c(1,2,3,4))
test.data<-abc
fit<-polr(data = test.data)
cuts<-numeric(length(fit$zeta)+2)
cuts[2:(length(fit$zeta)+1)]<-fit$zeta
cuts[c(1,length(cuts))]<-c(-Inf,Inf)
#create a vector of names of explanatory variables
variables<-attr(fit$terms,"term.labels")
#create the coefficient lookup function
#a convenient function for reading off the estimated coefficients for all
#the explanatory variables (including zero for baseline values)
coef.lookup<-function(variable,value){
if (!(variable %in% variables)) {
stop("variable not in model")
} else if (!(value %in% fit$xlevels[[variable]])) {
stop("value not observed for this variable")
} else if (fit$xlevels[[variable]][[1]]==value) {
return (0)
} else
return (fit$coefficients[[paste0(variable,value)]])
}
#create function P.X(X, outcome, variable, value) that will be treated
#as a function of X and give a specific probability for given outcome k for
#specific value of a specific variable
#what happens with invalid variables/values??
P.X<-function(X,outcome,variable,value){
(1+exp(X+coef.lookup(variable,value)-cuts[outcome+1]))^-1-
(1+exp(X+coef.lookup(variable,value)-cuts[outcome]  ))^-1
}
#get observed proportions of each variable in the data (including outcome)
counts.raw<-apply(test.data,2,table)
proportions.raw<-lapply(counts.raw,FUN = function(x){x/nrow(test.data)})
#create function proportions.implied(X, outcome=k, variable=v)
#that will give the implied proportion for outcome k in the population assuming
#X and v
#GIVEN VARIABLE e,g, GENDER, what is the implied proportion for outcome k?
implied.proportion<-function(X,outcome,variable){
implieds<-rep(0,length(fit$xlevels[[variable]]))
for (i in fit$xlevels[[variable]]){
implieds[i]<-P.X(X=X,outcome = outcome,variable = variable,value = i)*
proportions.raw[[variable]][[i]]
}
return(sum(implieds))
}
#GIVEN VARIABLE, find the sqaured error as a function of X
squared.error<-function(X,variable){
outcome.errors<-rep(0,length(fit$lev))
for (i in 1:length(fit$lev)){
outcome.errors[i]<-
(implied.proportion(X=X,outcome = i,variable = variable)-
proportions.raw[[1]][[i]])^2
}
return(sum(outcome.errors))
}
#find answer for given variable
recommend<-function(variable){
if (!(variable %in% variables)) {
stop("variable not in model")
}
optimised<-optimise(f = function(x){squared.error(x,variable)},
interval = c(-100,100))
message("The recommended value of X is ",optimised$minimum)
#create data frame with outcomes along the top and variable values down the side
#optimised.probs<-matrix(nrow = length(fit$lev),
#                        ncol = length(fit$xlevels[[variable]]))
optimised.probs<-data.frame(sapply(fit$xlevels[[variable]],
FUN=function(q){
P.X(X=optimised$minimum,
outcome = 1:length(fit$lev),
variable = variable,
value = q)}))
optimised.probs<-cbind(1:length(fit$lev),
sapply(1:length(fit$lev), FUN=function(q){
implied.proportion(X=optimised$minimum,
outcome = q,
variable = variable)}),
optimised.probs)
names(optimised.probs)[1]<-names(fit$model[1])
names(optimised.probs)[2]<-"implied probability"
optimised.probs
}
recommend("Grade")
recommend("Age")
recommend("VES1")
fit$coefficients
str(test.data)
library(devtools)
summary(test.data$Loc)
recommend("Loc")
has_devel()
devtools::load_all(".")
fit$coefficients
fit<-polr(data = test.data)
fit$coefficients
str(test.data)
test.data <- read.csv("~/GitHub/perfman/test data.csv")
View(test.data)
fit<-polr(data = test.data)
test.data$age <- factor(test.data$age, levels = c(1,2,3,4))
test.data$outcome <- factor(test.data$outcome, levels = c(1,2,3,4))
fit<-polr(data = test.data)
cuts<-numeric(length(fit$zeta)+2)
cuts[2:(length(fit$zeta)+1)]<-fit$zeta
cuts[c(1,length(cuts))]<-c(-Inf,Inf)
variables
variables<-attr(fit$terms,"term.labels")
variables
counts.raw<-apply(test.data,2,table)
proportions.raw<-lapply(counts.raw,FUN = function(x){x/nrow(test.data)})
recommend("gender")
proportions.raw$outcome
getwd()
fit.model<-function(dataset){
#fit the ordered logistic model
fit<-polr(data = dataset)
#create the cuts as a numeric vector
cuts<-numeric(length(fit$zeta)+2)
cuts[2:(length(fit$zeta)+1)]<-fit$zeta
cuts[c(1,length(cuts))]<-c(-Inf,Inf)
#get observed proportions of each variable in the data (including outcome)
counts.raw<-apply(dataset,2,table)
proportions.raw<-lapply(counts.raw,FUN = function(x){x/nrow(dataset)})
#create a vector of names of explanatory variables
variables<-attr(fit$terms,"term.labels")
}
fit.model(dataset)
fit.model(test.data)
min(100,-100)
max(100,-100)
lb<- -100
ub<100
ub<_100
ub<-100
min(lb,ub)
max(lb,ub)
devtools::load_all(".")
save(test.data)
use_data(test.data)
version()
R.version
devtools::load_all(".")
devtools::load_all(".")
library(MASS)
?polr
str(fit)
coef.lookup("gender","male")
devtools::load_all(".")
devtools::load_all(".")
library("roxygen2", lib.loc="~/R/win-library/3.2")
devtools::document()
?perfmna
?perfman
?fit.model
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::document()
?fit.model
?recommend
devtools::load_all(".")
devtools::document()
?recommend
?P.X
devtools::load_all(".")
str(test.data)
fit.model(test.data)
recommend("age")
recommend("disability")
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::document()
str(test.data)
load("~/GitHub/perfman/data/test.data.rda")
view(test.data)
View(test.data)
str(test.data)
summary(test.data$outcome)
summary(test.data$age)
devtools::load_all(".")
?test.data
??test.data
library(perfman)
?test.data
devtools::document()
?test.data
devtools::document()
devtools::check()
devtools::load_all(".")
devtools::check()
devtools::use_package("MASS")
devtools::load_all(".")
devtools::check()
devtools::load_all(".")
devtools::check()
devtools::load_all(".")
library(perfman)
library("roxygen2", lib.loc="~/R/win-library/3.2")
library("tools", lib.loc="C:/Program Files/R/R-3.2.2/library")
devtools::load_all(".")
library("MASS", lib.loc="C:/Program Files/R/R-3.2.2/library")
library(Rtools)
devtools::load_all(".")
source('~/GitHub/perfman/R/utility_functions.R', echo=TRUE)
